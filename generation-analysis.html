<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generation Analysis</title>
    <style>
        body { font-family: monospace; background: #1a1a1a; color: #fff; margin: 20px; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #444; border-radius: 5px; }
        .analysis-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 10px 0; }
        .test-sequence { background: #333; padding: 15px; margin: 10px 0; border-radius: 5px; }
        button { background: #2196F3; color: white; padding: 8px 16px; border: none; border-radius: 3px; cursor: pointer; margin: 5px; }
        button:hover { background: #0b7dda; }
        .result { margin: 10px 0; padding: 10px; background: #2a2a2a; border-radius: 3px; font-size: 11px; max-height: 400px; overflow-y: auto; }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #FF9800; }
        .info { color: #2196F3; }
        .step-indicator { display: inline-block; width: 20px; height: 20px; border-radius: 50%; margin-right: 10px; }
        .step-completed { background: #4CAF50; }
        .step-failed { background: #f44336; }
        .step-current { background: #FF9800; }
        .step-pending { background: #666; }
    </style>
</head>
<body>
    <h1>Ì¥¨ Generation Flow Analysis & Fix Process</h1>

    <div class="section">
        <h2>Ì≥ã Systematic Analysis Process</h2>
        <div class="test-sequence">
            <div class="step-indicator step-pending" id="analysis-step1"></div>
            <strong>Step 1: Component Loading Verification</strong><br>
            Verify all components are properly loaded and accessible
        </div>
        <div class="test-sequence">
            <div class="step-indicator step-pending" id="analysis-step2"></div>
            <strong>Step 2: Event System Analysis</strong><br>
            Check event subscriptions and communication between components
        </div>
        <div class="test-sequence">
            <div class="step-indicator step-pending" id="analysis-step3"></div>
            <strong>Step 3: Input Validation Testing</strong><br>
            Test input validation and state management
        </div>
        <div class="test-sequence">
            <div class="step-indicator step-pending" id="analysis-step4"></div>
            <strong>Step 4: Generation Pipeline Testing</strong><br>
            Test the core generation service and font rendering
        </div>
        <div class="test-sequence">
            <div class="step-indicator step-pending" id="analysis-step5"></div>
            <strong>Step 5: Output Display Testing</strong><br>
            Test output display and state management
        </div>
        <div class="test-sequence">
            <div class="step-indicator step-pending" id="analysis-step6"></div>
            <strong>Step 6: End-to-End Flow Testing</strong><br>
            Test complete user flow from input to output
        </div>
        <div class="test-sequence">
            <div class="step-indicator step-pending" id="analysis-step7"></div>
            <strong>Step 7: Error Analysis & Fixes</strong><br>
            Identify and fix any remaining issues
        </div>

        <div class="analysis-grid">
            <button onclick="runAnalysisStep(1)">Run Step 1</button>
            <button onclick="runAnalysisStep(2)">Run Step 2</button>
            <button onclick="runAnalysisStep(3)">Run Step 3</button>
            <button onclick="runAnalysisStep(4)">Run Step 4</button>
            <button onclick="runAnalysisStep(5)">Run Step 5</button>
            <button onclick="runAnalysisStep(6)">Run Step 6</button>
            <button onclick="runAnalysisStep(7)">Run Step 7</button>
            <button onclick="runAllAnalysis()">Run All Steps</button>
        </div>
        <div id="analysis-results" class="result"></div>
    </div>

    <div class="section">
        <h2>ÌæØ Targeted Fixes</h2>
        <button onclick="applyTargetedFixes()">Apply Targeted Fixes</button>
        <div id="fix-results" class="result"></div>
    </div>

    <script>
        let analysisStep = 0;
        let analysisResults = {};

        function log(sectionId, message, type = 'info') {
            const resultsDiv = document.getElementById(sectionId);
            const timestamp = new Date().toLocaleTimeString();
            resultsDiv.innerHTML += `<div class="${type}">[${timestamp}] ${message}</div>`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function clearResults(sectionId) {
            document.getElementById(sectionId).innerHTML = '';
        }

        function updateStepIndicator(stepNum, status) {
            const stepEl = document.getElementById(`analysis-step${stepNum}`);
            stepEl.className = 'step-indicator';

            if (status === 'completed') stepEl.classList.add('step-completed');
            else if (status === 'failed') stepEl.classList.add('step-failed');
            else if (status === 'current') stepEl.classList.add('step-current');
            else stepEl.classList.add('step-pending');
        }

        async function runAnalysisStep(stepNum) {
            clearResults('analysis-results');
            updateStepIndicator(stepNum, 'current');

            try {
                log('analysis-results', `Ì¥ç Running Analysis Step ${stepNum}...`, 'info');

                switch (stepNum) {
                    case 1:
                        await runComponentLoadingTest();
                        break;
                    case 2:
                        await runEventSystemTest();
                        break;
                    case 3:
                        await runInputValidationTest();
                        break;
                    case 4:
                        await runGenerationPipelineTest();
                        break;
                    case 5:
                        await runOutputDisplayTest();
                        break;
                    case 6:
                        await runEndToEndTest();
                        break;
                    case 7:
                        await runErrorAnalysis();
                        break;
                }

                updateStepIndicator(stepNum, 'completed');
                analysisResults[stepNum] = true;

            } catch (error) {
                log('analysis-results', `‚ùå Step ${stepNum} failed: ${error.message}`, 'error');
                updateStepIndicator(stepNum, 'failed');
                analysisResults[stepNum] = false;
            }
        }

        async function runComponentLoadingTest() {
            log('analysis-results', 'ÌøóÔ∏è Testing component loading...', 'info');

            const components = [
                { name: 'AppConfig', check: !!window.AppConfig },
                { name: 'EventBus', check: !!window.app?.eventBus },
                { name: 'UIController', check: !!window.app?.uiController },
                { name: 'GenerationService', check: !!window.app?.generationService },
                { name: 'FontManager', check: !!window.app?.fontManager },
                { name: 'InputPanel', check: !!window.app?.inputPanel },
                { name: 'OutputPanel', check: !!window.app?.outputPanel },
                { name: 'TextInputComponent', check: !!window.app?.inputPanel?.getTextInputComponent() },
                { name: 'GenerateButtonComponent', check: !!window.app?.inputPanel?.getGenerateButtonComponent() },
                { name: 'FontSelectorComponent', check: !!window.app?.inputPanel?.getFontSelectorComponent() }
            ];

            let loaded = 0;
            components.forEach(({ name, check }) => {
                if (check) {
                    log('analysis-results', `‚úÖ ${name} loaded`, 'success');
                    loaded++;
                } else {
                    log('analysis-results', `‚ùå ${name} not loaded`, 'error');
                }
            });

            log('analysis-results', `Ì≥ä Component loading: ${loaded}/${components.length} successful`);

            if (loaded < 8) {
                log('analysis-results', '‚ö†Ô∏è Critical components missing - check script loading', 'warning');
            }
        }

        async function runEventSystemTest() {
            log('analysis-results', 'Ì≥° Testing event system...', 'info');

            if (!window.app?.eventBus) {
                log('analysis-results', '‚ùå EventBus not available', 'error');
                return;
            }

            // Check event subscriptions
            const stats = window.app.eventBus.debugSubscriptions();
            log('analysis-results', `Ì≥ä Event subscriptions: ${Object.keys(stats).length} event types`);

            // Test critical event paths
            const criticalEvents = [
                'ui:generate:click',
                'request:text:gen',
                'text:gen:start',
                'text:gen:complete',
                'text:input:changed',
                'font:changed'
            ];

            criticalEvents.forEach(event => {
                const listeners = stats[event] || 0;
                const status = listeners > 0 ? '‚úÖ' : '‚ùå';
                log('analysis-results', `${status} ${event}: ${listeners} listener(s)`);
            });
        }

        async function runInputValidationTest() {
            log('analysis-results', 'Ì≥ù Testing input validation...', 'info');

            if (window.app?.inputPanel?.getTextInputComponent()) {
                const textInput = window.app.inputPanel.getTextInputComponent();

                // Test validation
                textInput.setText('VALIDATION TEST');
                const isValid = textInput.isValid();

                if (isValid) {
                    log('analysis-results', '‚úÖ Input validation working', 'success');
                } else {
                    log('analysis-results', '‚ùå Input validation failed', 'error');
                }

                // Test empty input
                textInput.setText('');
                const isEmptyValid = textInput.isValid();

                if (!isEmptyValid) {
                    log('analysis-results', '‚úÖ Empty input properly rejected', 'success');
                } else {
                    log('analysis-results', '‚ùå Empty input should be rejected', 'error');
                }

            } else {
                log('analysis-results', '‚ùå TextInputComponent not available', 'error');
            }
        }

        async function runGenerationPipelineTest() {
            log('analysis-results', '‚öôÔ∏è Testing generation pipeline...', 'info');

            if (window.app?.generationService) {
                try {
                    // Listen for events
                    window.app.eventBus.on('text:gen:start', () => {
                        log('analysis-results', '‚úÖ Generation started', 'success');
                    });

                    window.app.eventBus.on('text:gen:complete', (result) => {
                        log('analysis-results', `‚úÖ Generation completed: ${result.ascii?.length || 0} characters`, 'success');
                    });

                    // Test direct generation
                    const result = await window.app.generationService.generateText({
                        text: 'PIPELINE TEST',
                        fontName: 'standard',
                        color: 'none',
                        animation: 'none'
                    });

                    // Cleanup
                    setTimeout(() => {
                        window.app.eventBus.off('text:gen:start');
                        window.app.eventBus.off('text:gen:complete');
                    }, 1000);

                } catch (error) {
                    log('analysis-results', `‚ùå Generation pipeline error: ${error.message}`, 'error');
                }
            } else {
                log('analysis-results', '‚ùå GenerationService not available', 'error');
            }
        }

        async function runOutputDisplayTest() {
            log('analysis-results', 'Ì≥∫ Testing output display...', 'info');

            if (window.app?.outputPanel) {
                try {
                    // Test display
                    const testContent = "DISPLAY\nTEST";
                    const displayed = window.app.outputPanel.display(testContent);

                    if (displayed) {
                        log('analysis-results', '‚úÖ Output display working', 'success');
                    } else {
                        log('analysis-results', '‚ùå Output display failed', 'error');
                    }

                    // Check output element
                    const outputEl = document.getElementById('ascii-output');
                    if (outputEl && outputEl.textContent.includes('DISPLAY')) {
                        log('analysis-results', '‚úÖ Output element updated', 'success');
                    } else {
                        log('analysis-results', '‚ùå Output element not updated', 'error');
                    }

                } catch (error) {
                    log('analysis-results', `‚ùå Output display error: ${error.message}`, 'error');
                }
            } else {
                log('analysis-results', '‚ùå OutputPanel not available', 'error');
            }
        }

        async function runEndToEndTest() {
            log('analysis-results', 'Ì¥Ñ Testing end-to-end flow...', 'info');

            try {
                // Set up test
                if (window.app?.inputPanel?.getTextInputComponent()) {
                    window.app.inputPanel.getTextInputComponent().setText('END TO END TEST');
                }

                // Listen for complete flow
                const flowEvents = [];
                window.app.eventBus.on('text:input:changed', () => flowEvents.push('input'));
                window.app.eventBus.on('ui:generate:click', () => flowEvents.push('click'));
                window.app.eventBus.on('request:text:gen', () => flowEvents.push('request'));
                window.app.eventBus.on('text:gen:start', () => flowEvents.push('start'));
                window.app.eventBus.on('text:gen:complete', () => flowEvents.push('complete'));

                // Trigger flow
                window.app.eventBus.emit('ui:generate:click');

                // Check results
                setTimeout(() => {
                    const expectedEvents = ['input', 'click', 'request', 'start', 'complete'];
                    const missingEvents = expectedEvents.filter(event => !flowEvents.includes(event));

                    if (missingEvents.length === 0) {
                        log('analysis-results', '‚úÖ End-to-end flow working', 'success');
                    } else {
                        log('analysis-results', `‚ùå Missing events: ${missingEvents.join(', ')}`, 'error');
                    }

                    // Cleanup
                    window.app.eventBus.off('text:input:changed');
                    window.app.eventBus.off('ui:generate:click');
                    window.app.eventBus.off('request:text:gen');
                    window.app.eventBus.off('text:gen:start');
                    window.app.eventBus.off('text:gen:complete');
                }, 2000);

            } catch (error) {
                log('analysis-results', `‚ùå End-to-end test error: ${error.message}`, 'error');
            }
        }

        async function runErrorAnalysis() {
            log('analysis-results', 'Ì¥ç Running error analysis and fixes...', 'info');

            // Check for common issues
            const issues = [];

            // Check if components are properly connected
            if (!window.app?.inputPanel?.getTextInputComponent()) {
                issues.push('TextInputComponent not properly connected');
            }

            if (!window.app?.inputPanel?.getGenerateButtonComponent()) {
                issues.push('GenerateButtonComponent not properly connected');
            }

            // Check event subscriptions
            if (window.app?.eventBus) {
                const stats = window.app.eventBus.debugSubscriptions();
                if (!stats['ui:generate:click'] || stats['ui:generate:click'] === 0) {
                    issues.push('Generate click event not subscribed');
                }
                if (!stats['request:text:gen'] || stats['request:text:gen'] === 0) {
                    issues.push('Text generation request event not subscribed');
                }
            }

            // Check DOM elements
            if (!document.getElementById('text-input')) {
                issues.push('Text input DOM element missing');
            }
            if (!document.getElementById('generate-main')) {
                issues.push('Generate button DOM element missing');
            }

            if (issues.length > 0) {
                issues.forEach(issue => {
                    log('analysis-results', `‚ùå ${issue}`, 'error');
                });
                log('analysis-results', 'Ì≤° These issues need to be fixed', 'warning');
            } else {
                log('analysis-results', '‚úÖ No critical issues found', 'success');
            }
        }

        async function runAllAnalysis() {
            clearResults('analysis-results');

            for (let i = 1; i <= 7; i++) {
                await runAnalysisStep(i);
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            // Summary
            const passed = Object.values(analysisResults).filter(Boolean).length;
            log('analysis-results', `Ì≥ä Analysis Summary: ${passed}/7 steps completed`);

            if (passed >= 6) {
                log('analysis-results', 'Ìæâ Analysis complete - system should be working!', 'success');
            } else {
                log('analysis-results', `‚ùå ${7 - passed} step(s) failed. Check above for details.`, 'error');
            }
        }

        async function applyTargetedFixes() {
            clearResults('fix-results');

            try {
                log('fix-results', 'Ì¥ß Applying targeted fixes...', 'info');

                // Fix 1: Ensure proper component initialization
                if (window.app?.inputPanel) {
                    // Refresh components
                    window.app.inputPanel.refresh();
                    log('fix-results', '‚úÖ Component refresh applied', 'success');
                }

                // Fix 2: Clear any stuck states
                if (window.app?.uiController?.recover) {
                    window.app.uiController.recover();
                    log('fix-results', '‚úÖ State recovery applied', 'success');
                }

                // Fix 3: Clean event system
                if (window.app?.eventBus?.cleanup) {
                    window.app.eventBus.cleanup();
                    log('fix-results', '‚úÖ Event cleanup applied', 'success');
                }

                // Fix 4: Reset output state
                if (window.app?.outputPanel?.setDefaultState) {
                    window.app.outputPanel.setDefaultState();
                    log('fix-results', '‚úÖ Output reset applied', 'success');
                }

                log('fix-results', 'ÌæØ All targeted fixes applied', 'success');

            } catch (error) {
                log('fix-results', `‚ùå Fix application error: ${error.message}`, 'error');
            }
        }

        // Auto-start analysis
        setTimeout(() => {
            if (window.app) {
                log('analysis-results', '‚úÖ App loaded successfully', 'success');
            } else {
                log('analysis-results', '‚ùå App not loaded - check for initialization errors', 'error');
            }
        }, 500);
    </script>
</body>
</html>
