/**
 * Simple ASCII Art Generator - MVP Version
 * All fonts bundled inline for simplicity
 */

// Minimal built-in FontManager
class FontManager {
    constructor() {
        this.fonts = null;
    }

    ensureFonts() {
        if (this.fonts) return;
        const fonts = {};

        // ===== ENHANCED CORE FONTS =====

        // Standard (improved clarity)
        fonts.standard = {
            name: 'standard',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': [' ??? ', '   ? ', '  ?  ', '     ', '  ?  '],
                '0': [' ### ', '#   #', '#   #', '#   #', ' ### '],
                '1': ['  #  ', ' ##  ', '  #  ', '  #  ', ' ### '],
                '2': [' ### ', '    #', '  #  ', ' #   ', '#####'],
                '3': [' ### ', '    #', '  ## ', '    #', ' ### '],
                '4': ['#   #', '#   #', ' ####', '    #', '    #'],
                '5': ['#####', '#    ', ' ### ', '    #', '##### '],
                '6': [' ### ', '#    ', '#### ', '#   #', ' ### '],
                '7': ['#####', '    #', '   # ', '  #  ', ' #   '],
                '8': [' ### ', '#   #', ' ### ', '#   #', ' ### '],
                '9': [' ### ', '#   #', ' ####', '    #', ' ### '],
                'A': [' ### ', '#   #', '#####', '#   #', '#   #'],
                'B': ['#### ', '#   #', '#### ', '#   #', '#### '],
                'C': [' ### ', '#    ', '#    ', '#    ', ' ### '],
                'D': ['#### ', '#   #', '#   #', '#   #', '#### '],
                'E': ['#####', '#    ', '#### ', '#    ', '#####'],
                'F': ['#####', '#    ', '#### ', '#    ', '#    '],
                'G': [' ### ', '#    ', '#  ##', '#   #', ' ### '],
                'H': ['#   #', '#   #', '#####', '#   #', '#   #'],
                'I': ['#####', '  #  ', '  #  ', '  #  ', '#####'],
                'J': [' ###', '   #', '   #', '#  #', ' ## '],
                'K': ['#   #', '#  # ', '###  ', '#  # ', '#   #'],
                'L': ['#    ', '#    ', '#    ', '#    ', '#####'],
                'M': ['#   #', '## ##', '# # #', '#   #', '#   #'],
                'N': ['#   #', '##  #', '# # #', '#  ##', '#   #'],
                'O': [' ### ', '#   #', '#   #', '#   #', ' ### '],
                'P': ['#### ', '#   #', '#### ', '#    ', '#    '],
                'Q': [' ### ', '#   #', '#   #', '#  # ', ' ####'],
                'R': ['#### ', '#   #', '#### ', '#  # ', '#   #'],
                'S': [' ####', '#    ', ' ### ', '    #', '#### '],
                'T': ['#####', '  #  ', '  #  ', '  #  ', '  #  '],
                'U': ['#   #', '#   #', '#   #', '#   #', ' ### '],
                'V': ['#   #', '#   #', '#   #', ' # # ', '  #  '],
                'W': ['#   #', '#   #', '# # #', '## ##', '#   #'],
                'X': ['#   #', ' # # ', '  #  ', ' # # ', '#   #'],
                'Y': ['#   #', ' # # ', '  #  ', '  #  ', '  #  '],
                'Z': ['#####', '   # ', '  #  ', ' #   ', '#####']
            }
        };

        // Block (solid)
        fonts.block = {
            name: 'block',
            height: 5,
            glyphs: this._makeBlockVariant(fonts.standard.glyphs)
        };

        // Mini 3-row compact
        fonts.mini = {
            name: 'mini',
            height: 3,
            glyphs: {
                ' ': ['   ', '   ', '   '],
                '?': [' ? ', ' ? ', '   '],
                '0': ['###', '# #', '###'],
                '1': [' ##', '  #', '###'],
                '2': ['## ', ' # ', '###'],
                '3': ['## ', ' ##', '## '],
                '4': ['# #', '###', '  #'],
                '5': ['###', '##', '## '],
                '6': ['## ', '###', '## '],
                '7': ['###', '  #', '  #'],
                '8': ['###', '###', '###'],
                '9': ['###', '## ', '###'],
                'A': [' # ', '# #', '###'],
                'B': ['##', '##', '##'],
                'C': [' ##', '#  ', '## '],
                'D': ['##', '# #', '##'],
                'E': ['###', '##', '###'],
                'F': ['###', '##', '#  '],
                'G': [' ##', '# #', '## '],
                'H': ['# #', '###', '# #'],
                'I': ['###', ' # ', '###'],
                'J': ['###', '  #', '## '],
                'K': ['# #', '##', '# #'],
                'L': ['#  ', '#  ', '###'],
                'M': ['###', '###', '# #'],
                'N': ['##', '###', '# #'],
                'O': ['###', '# #', '###'],
                'P': ['##', '##', '#  '],
                'Q': ['###', '# #', '###'],
                'R': ['##', '##', '# #'],
                'S': [' ##', '##', '## '],
                'T': ['###', ' # ', ' # '],
                'U': ['# #', '# #', '###'],
                'V': ['# #', '# #', ' # '],
                'W': ['# #', '###', '###'],
                'X': ['# #', ' # ', '# #'],
                'Y': ['# #', ' # ', ' # '],
                'Z': ['###', ' # ', '###']
            }
        };

        // Small (compact but readable)
        fonts.small = {
            name: 'small',
            height: 5,
            glyphs: {
                ' ': ['   ', '   ', '   ', '   ', '   '],
                '?': [' ? ', ' ? ', '   ', '   ', '   '],
                '0': ['## ', '# #', '# #', '# #', '## '],
                '1': [' # ', '## ', ' # ', ' # ', '###'],
                '2': ['## ', '  #', ' ##', ' #  ', '###'],
                '3': ['## ', '  #', ' ## ', '  #', '## '],
                '4': ['# #', '###', '  #', '  #', '  #'],
                '5': ['###', '#  ', '## ', '  #', '## '],
                '6': ['## ', '#  ', '###', '# #', '## '],
                '7': ['###', '  #', ' # ', '#  ', '#  '],
                '8': ['## ', '# #', '## ', '# #', '## '],
                '9': ['## ', '# #', '###', '  #', '## '],
                'A': [' # ', '# #', '###', '# #', '# #'],
                'B': ['##', '# #', '##', '# #', '##'],
                'C': [' ##', '#  ', '#  ', '#  ', '##'],
                'D': ['##', '# #', '# #', '# #', '##'],
                'E': ['###', '#  ', '## ', '#  ', '###'],
                'F': ['###', '#  ', '## ', '#  ', '#  '],
                'G': [' ##', '#  ', '# #', '# #', '## '],
                'H': ['# #', '# #', '###', '# #', '# #'],
                'I': ['###', ' # ', ' # ', ' # ', '###'],
                'J': ['  #', '  #', '  #', '# #', '## '],
                'K': ['# #', ' ##', '#  ', ' ##', '# #'],
                'L': ['#  ', '#  ', '#    ', '#  ', '###'],
                'M': ['# #', '###', '# #', '# #', '# #'],
                'N': ['##', '# #', '# #', '# #', '##'],
                'O': ['## ', '# #', '# #', '# #', '## '],
                'P': ['##', '# #', '##', '#  ', '#  '],
                'Q': ['## ', '# #', '# #', '## ', '  #'],
                'R': ['##', '# #', '##', ' ##', '# #'],
                'S': [' ##', '#  ', '## ', '  #', '## '],
                'T': ['###', ' # ', ' # ', ' # ', ' # '],
                'U': ['# #', '# #', '# #', '# #', '## '],
                'V': ['# #', '# #', '# #', ' ##', ' # '],
                'W': ['# #', '# #', '###', '###', '# #'],
                'X': ['# #', ' ##', ' # ', ' ##', '# #'],
                'Y': ['# #', ' ##', ' # ', ' # ', ' # '],
                'Z': ['###', '  #', ' # ', ' # ', '###']
            }
        };

        // Bubble (rounded)
        fonts.bubble = {
            name: 'bubble',
            height: 5,
            glyphs: {
                ' ': ['    ', '    ', '    ', '    ', '    '],
                '?': [' ?? ', '  ? ', '    ', '  ? ', '    '],
                '0': [' oo ', 'o  o', 'o  o', 'o  o', ' oo '],
                '1': [' o  ', 'oo  ', ' o  ', ' o  ', 'ooo '],
                '2': [' oo ', 'o  o', '   o', ' o  ', 'oooo'],
                '3': [' oo ', 'o  o', '  o ', 'o  o', ' oo '],
                '4': ['o   ', 'o  o', 'oooo', '   o', '   o'],
                '5': ['oooo', 'o   ', ' oo ', '   o', ' oo '],
                '6': [' oo ', 'o   ', 'ooo ', 'o  o', ' oo '],
                '7': ['oooo', '   o', '  o ', ' o  ', ' o  '],
                '8': [' oo ', 'o  o', ' oo ', 'o  o', ' oo '],
                '9': [' oo ', 'o  o', ' ooo', '   o', ' oo '],
                'A': [' oo ', 'o  o', 'oooo', 'o  o', 'o  o'],
                'B': ['ooo ', 'o  o', 'ooo ', 'o  o', 'ooo '],
                'C': [' oo ', 'o   ', 'o   ', 'o   ', ' oo '],
                'D': ['ooo ', 'o  o', 'o  o', 'o  o', 'ooo '],
                'E': ['oooo', 'o   ', 'ooo ', 'o   ', 'oooo'],
                'F': ['oooo', 'o   ', 'ooo ', 'o   ', 'o   '],
                'G': [' oo ', 'o   ', 'o oo', 'o  o', ' oo '],
                'H': ['o  o', 'o  o', 'oooo', 'o  o', 'o  o'],
                'I': [' ooo', '  o ', '  o ', '  o ', ' ooo'],
                'J': ['  oo', '   o', '   o', 'o  o', ' oo '],
                'K': ['o  o', ' oo ', 'o   ', ' oo ', 'o  o'],
                'L': ['o   ', 'o   ', 'o   ', 'o   ', 'oooo'],
                'M': ['o   o', 'oo oo', 'o o o', 'o   o', 'o   o'],
                'N': ['oo  o', 'o o o', 'o o o', 'o  oo', 'o   o'],
                'O': [' oo ', 'o  o', 'o  o', 'o  o', ' oo '],
                'P': ['ooo ', 'o  o', 'ooo ', 'o   ', 'o   '],
                'Q': [' oo ', 'o  o', 'o  o', 'o oo', ' ooo'],
                'R': ['ooo ', 'o  o', 'ooo ', 'o  o', 'o  o'],
                'S': [' ooo', 'o   ', ' oo ', '   o', 'ooo '],
                'T': ['oooo', '  o ', '  o ', '  o ', '  o '],
                'U': ['o  o', 'o  o', 'o  o', 'o  o', ' oo '],
                'V': ['o  o', 'o  o', 'o  o', ' oo ', '  o '],
                'W': ['o   o', 'o   o', 'o o o', 'oo oo', 'o   o'],
                'X': ['o  o', ' oo ', '  o ', ' oo ', 'o  o'],
                'Y': ['o  o', ' oo ', '  o ', '  o ', '  o '],
                'Z': ['oooo', '   o', '  o ', ' #   ', '#####']
            }
        };

        // 3D (depth effect)
        fonts['3d'] = {
            name: '3d',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': ['  ?  ', '  ?  ', '     ', '  ?  ', '     '],
                '0': [' ### ', '#  ##', '#  ##', ' ### ', '     '],
                '1': ['   # ', '  ## ', '   # ', '   # ', '  ###'],
                '2': [' ### ', '#   #', '   # ', '  #  ', ' ####'],
                '3': [' ### ', '   ##', '   # ', '#  ##', ' ### '],
                '4': ['#   #', '#   #', ' #### ', '    #', '    #'],
                '5': [' #### ', '#     ', ' #### ', '     #', ' #### '],
                '6': [' ### ', '#    ', ' ###', '#  ##', ' ### '],
                '7': [' ####', '    #', '   # ', '  #  ', ' #   '],
                '8': [' ### ', '#  ##', ' ### ', '#  ##', ' ### '],
                '9': [' ### ', '#  ##', ' ####', '    #', ' ### '],
                'A': ['  #  ', ' ###', '#   #', ' #### ', '#   #'],
                'B': [' #### ', '#    #', ' ### ', '#    #', ' #### '],
                'C': [' ###', '#   ', '#   ', '#   ', ' ###'],
                'D': [' #### ', '#    #', '#    #', '#    #', ' #### '],
                'E': [' #### ', '#     ', ' ### ', '#     ', ' #### '],
                'F': [' #### ', '#     ', ' ### ', '#     ', '#     '],
                'G': [' ###', '#   ', '#  ##', '#   #', ' ###'],
                'H': ['#   #', '#   #', ' #### ', '#   #', '#   #'],
                'I': [' ### ', '  #  ', '  #  ', '  #  ', ' ### '],
                'J': ['    #', '    #', '    #', '#   #', ' ### '],
                'K': ['#   #', '  ##', ' #   ', '  ##', '#   #'],
                'L': ['#    ', '#    ', '#    ', '#    ', ' #### '],
                'M': ['#   #', '## ##', '# # #', '#   #', '#   #'],
                'N': ['#   #', '##  #', '# # #', '#  ##', '#   #'],
                'O': [' ### ', '#   #', '#   #', '#   #', ' ### '],
                'P': [' ####', '#   #', ' #### ', '#    ', '#    '],
                'Q': [' ### ', '#   #', '#   #', ' ### ', '    #'],
                'R': [' ####', '#   #', ' #### ', '#  #░', '#   #'],
                'S': [' ####', '#    ', ' ### ', '    #', ' ####'],
                'T': [' ####', '  #  ', '  #  ', '  #  ', '  #  '],
                'U': ['#   #', '#   #', '#   #', '#   #', ' ### '],
                'V': ['#   #', '#   #', '#   #', ' # # ', '  #  '],
                'W': ['#   #', '#   #', '# # #', '## ##', '#   #'],
                'X': ['#   #', ' # # ', '  #  ', ' # # ', '#   #'],
                'Y': ['#   #', ' # # ', '  #  ', '  #  ', '  #  '],
                'Z': [' #### ', '    #', '   # ', '  #  ', ' #### ']
            }
        };

        // ===== NEW FONT STYLES (10 NEW) =====

        // Outlined (box style)
        fonts.outlined = {
            name: 'outlined',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': [' [?] ', '  ?  ', '     ', '  ?  ', '     '],
                '0': [' ___ ', '|   |', '|   |', '|   |', ' ‾‾‾ '],
                '1': ['  |  ', ' _|  ', '  |  ', '  |  ', ' _|_ '],
                '2': [' ___ ', '    |', '  _  ', ' |   ', ' ____ '],
                '3': [' ___ ', '    |', '  __ ', '    |', ' ‾‾‾ '],
                '4': ['|   |', '|___|', '    |', '    |', '    |'],
                '5': [' ___ ', '|    ', ' ‾‾| ', '    |', '___  '],
                '6': [' ___ ', '|    ', '| __ ', '|   |', ' ‾‾‾ '],
                '7': [' ___ ', '    |', '   | ', '  |  ', '  |  '],
                '8': [' ___ ', '|   |', ' ___ ', '|   |', ' ‾‾‾ '],
                '9': [' ___ ', '|   |', ' ____', '    |', ' ‾‾‾ '],
                'A': ['  _  ', ' / \\ ', '/   \\', '\\___/', '     '],
                'B': [' ___ ', '|   |', '|___|', '|   |', '|___|'],
                'C': [' ___ ', '|    ', '|    ', '|    ', ' ‾‾‾ '],
                'D': [' ___ ', '|   \\', '|   |', '|   /', ' ‾‾‾ '],
                'E': [' ___ ', '|    ', '|___ ', '|    ', '|___ '],
                'F': [' ___ ', '|    ', '|___ ', '|    ', '|    '],
                'G': [' ___ ', '|    ', '| __ ', '|   |', ' ‾‾‾ '],
                'H': ['|   |', '|   |', '|___|', '|   |', '|   |'],
                'I': [' ___ ', '  |  ', '  |  ', '  |  ', ' ___ '],
                'J': ['  __ ', '    |', '    |', '|   |', ' ___ '],
                'K': ['|   |', '|  / ', '| /  ', '|  \\\\', '|   |'],
                'L': ['|    ', '|    ', '|    ', '|    ', '|___ '],
                'M': ['|   |', '|\\ /|', '| V |', '|   |', '|   |'],
                'N': ['|\\  |', '| \\ |', '|  \\|', '|   |', '|   |'],
                'O': [' ___ ', '|   |', '|   |', '|   |', ' ‾‾‾ '],
                'P': [' ___ ', '|   |', '|___ ', '|    ', '|    '],
                'Q': [' ___ ', '|   |', '|   |', '|  / ', ' ‾\\ '],
                'R': [' ___ ', '|   |', '|___ ', '|  \\\\', '|   |'],
                'S': [' ___ ', '|    ', ' ___ ', '    |', '___  '],
                'T': [' ___ ', '  |  ', '  |  ', '  |  ', '  |  '],
                'U': ['|   |', '|   |', '|   |', '|   |', ' ‾‾‾ '],
                'V': ['|   |', '|   |', '|   |', ' | | ', '  V  '],
                'W': ['|   |', '|   |', '| | |', '| | |', '  W  '],
                'X': ['|   |', ' \\ / ', '  X  ', ' / \\ ', '|   |'],
                'Y': ['|   |', ' \\ / ', '  Y  ', '  |  ', '  |  '],
                'Z': [' ___ ', '   / ', '  /  ', ' /   ', '/‾‾‾ ']
            }
        };

        // Italic (slanted)
        fonts.italic = {
            name: 'italic',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': ['  ?  ', '  ?  ', '     ', '  ?  ', '     '],
                '0': ['  ##/', '#  / ', '#  \\ ', '#  \\ ', ' ##\\ '],
                '1': ['  / ', ' // ', '  / ', '  / ', '////'],
                '2': [' ##/', '   / ', '  /  ', ' /   ', '///  '],
                '3': [' ##/', '   / ', ' //  ', '   / ', '###  '],
                '4': ['#   #', '#  / ', '/////', '   / ', '   / '],
                '5': ['///  ', '/    ', ' ##/ ', '    / ', '###  '],
                '6': ['##/ ', '/    ', '#### ', '/   / ', ' ##\\ '],
                '7': ['/// ', '   / ', '  /  ', ' /   ', '/    '],
                '8': ['##/ ', '/   / ', ' ##/ ', '/   / ', ' ##\\ '],
                '9': ['##/ ', '/   / ', ' ###/ ', '   / ', ' ###/ '],
                'A': ['  / ', ' / \\ ', '/   \\ ', '\\  / ', ' \\ / '],
                'B': ['##/ ', '/  / ', '##/ ', '/  / ', '##/ '],
                'C': [' ##/', '/   ', '/   ', '/   ', ' ##\\'],
                'D': ['##/ ', '/  / ', '/  / ', '/  / ', '##\\'],
                'E': ['///  ', '/    ', '//   ', '/    ', '///  '],
                'F': ['///  ', '/    ', '//   ', '/    ', '/    '],
                'G': [' ##/ ', '/    ', '/  ##', '/   / ', ' ##\\ '],
                'H': ['/  / ', '/  / ', '/////', '/  / ', '/  / '],
                'I': [' /// ', '  /  ', '  /  ', '  /  ', ' /// '],
                'J': ['  ###', '    / ', '    / ', ' /  / ', ' ##/ '],
                'K': ['/   / ', '  //  ', ' //   ', '  //  ', '/   / '],
                'L': ['/    ', '|    ', '|    ', '|    ', '//// '],
                'M': ['/   / ', '\\ // / ', ' / / ', '/   / ', '/   / '],
                'N': [' \\ / ', '\\\\/ / ', ' / / ', '/  \\\\ ', '/   / '],
                'O': [' ##/ ', '/   / ', '/   / ', '/   / ', ' ##\\ '],
                'P': ['##/ ', '/  / ', '##/ ', '/   ', '/   '],
                'Q': [' ##/ ', '/   / ', '/   / ', ' ##/ ', '   \\\\'],
                'R': ['##/ ', '/  / ', '##/ ', '/  / ', '/   / '],
                'S': [' ##/ ', '/    ', ' ##/ ', '    / ', '###  '],
                'T': [' /// ', '  /  ', '  /  ', '  /  ', '  /  '],
                'U': ['/   / ', '/   / ', '/   / ', '/   / ', ' ##/ '],
                'V': ['/   / ', '/   / ', ' / / ', ' / / ', '  /  '],
                'W': ['/   / ', '/   / ', ' / / / ', ' / / / ', '/   / '],
                'X': ['/   / ', ' / / ', '  /  ', ' / \\ ', '/   / '],
                'Y': ['/   / ', ' / / ', '  /  ', '  /  ', '  /  '],
                'Z': [' /// ', '   / ', '  /  ', ' /   ', '//// ']
            }
        };

        // Shadow (3D drop shadow)
        fonts.shadow = {
            name: 'shadow',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': [' ??? ', '  ?░ ', ' ░   ', '  ?░ ', ' ░░░ '],
                '0': [' ### ', '#  #░', '#  #░', '#  #░', ' ###░'],
                '1': ['  # ░', ' ##░ ', '  #░ ', '  #░ ', ' ###░'],
                '2': [' ###░', '#   #', '   #░', '  # ░', '#####'],
                '3': [' ###░', '   ##', '  ##░', '   ##', ' ###░'],
                '4': ['#   #', '#   #', ' ####', '   #░', '   ##'],
                '5': [' ####', '#   ░', ' ###░', '    #', ' ###░'],
                '6': [' ###░', '#   ░', ' ####', '#   #', ' ###░'],
                '7': ['#####', '   #░', '  #░ ', '  # ░', '  ##░'],
                '8': [' ###░', '#   #', ' ###░', '#   #', ' ###░'],
                '9': [' ###░', '#   #', ' ####', '   ##', ' ###░'],
                'A': [' ### ', '#  #░', ' ####', '#   #', '#   #'],
                'B': [' ####', '#   #', ' ####', '#   #', ' ####'],
                'C': [' ### ', '#   ░', '#    ', '#   ░', ' ### '],
                'D': [' ####', '#   #', '#   #', '#   #', ' ####'],
                'E': [' ####', '#    ', ' ####', '#    ', ' ####'],
                'F': [' ####', '#    ', ' ### ', '#    ', '#    '],
                'G': [' ### ', '#    ', '#  ##', '#   #', ' ### '],
                'H': ['#   #', '#   #', ' ####', '#   #', '#   #'],
                'I': [' ### ', '  #  ', '  #  ', '  #  ', ' ### '],
                'J': ['    #', '    #', '    #', '#   #', ' ### '],
                'K': ['#   #', '  ##', ' #   ', '  ##', '#   #'],
                'L': ['#    ', '#    ', '#    ', '#    ', ' ####'],
                'M': ['#   #', '## ##', '# # #', '#   #', '#   #'],
                'N': ['#   #', '##  #', '# # #', '#  ##', '#   #'],
                'O': [' ### ', '#   #', '#   #', '#   #', ' ### '],
                'P': [' ####', '#   #', ' #### ', '#    ', '#    '],
                'Q': [' ### ', '#   #', '#   #', ' ####', '   ##'],
                'R': [' ####', '#   #', ' #### ', '#  #░', '#   #'],
                'S': [' ####', '#    ', ' ### ', '    #', ' ####'],
                'T': [' ####', '  #  ', '  #  ', '  #  ', '  #  '],
                'U': ['#   #', '#   #', '#   #', '#   #', ' ### '],
                'V': ['#   #', '#   #', '#   #', ' # # ', '  #  '],
                'W': ['#   #', '#   #', '# # #', '## ##', '#   #'],
                'X': ['#   #', ' # # ', '  #  ', ' # # ', '#   #'],
                'Y': ['#   #', ' # # ', '  #  ', '  #  ', '  #  '],
                'Z': [' ####', '   # ', '  #  ', ' #   ', ' ####']
            }
        };

        // Retro (80s style with slashes)
        fonts.retro = {
            name: 'retro',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': [' |?| ', '  ?  ', '     ', '  ?  ', '     '],
                '0': ['|###|', '#   #', '#   #', '#   #', '|###|'],
                '1': ['  |  ', ' ||  ', '  |  ', '  |  ', ' |||'],
                '2': ['|###|', '    #', '  |  ', '  #  ', '|###|'],
                '3': ['|###|', '    #', ' |#| ', '    #', '|###|'],
                '4': ['|   |', '#   #', '|###|', '    #', '    |'],
                '5': ['|###|', '#    ', '|##| ', '    #', '|###|'],
                '6': ['|###|', '#    ', '|###|', '#   #', '|###|'],
                '7': ['|###|', '    #', '   | ', '  |  ', ' |   '],
                '8': ['|###|', '#   #', '|###|', '#   #', '|###|'],
                '9': ['|###|', '#   #', '|####', '    #', '|###|'],
                'A': [' |#| ', ' # # ', '|###|', '#   #', '#   #'],
                'B': ['|##| ', '#   #', '|##| ', '#   #', '|##| '],
                'C': [' |#| ', '#    ', '#    ', '#    ', ' |#| '],
                'D': ['|##| ', '#   #', '#   #', '#   #', '|##| '],
                'E': ['|###|', '#    ', '|### ', '#    ', '|###|'],
                'F': ['|###|', '#    ', '|### ', '#    ', '#    '],
                'G': [' |#| ', '#    ', '# |#|', '#   #', ' |#| '],
                'H': ['#   #', '#   #', '|###|', '#   #', '#   #'],
                'I': ['|###|', '  #  ', '  #  ', '  #  ', '|###|'],
                'J': ['|###|', '   # ', '   # ', '#  # ', ' ##  '],
                'K': ['#   #', '#  | ', '|#   ', '#  | ', '#   #'],
                'L': ['#    ', '#    ', '#    ', '#    ', '|###|'],
                'M': ['#   #', '## ##', '# # #', '#   #', '#   #'],
                'N': ['#   #', '##  #', '# # #', '#  ##', '#   #'],
                'O': [' |#| ', '#   #', '#   #', '#   #', ' |#| '],
                'P': ['|##| ', '#   #', '|##| ', '#    ', '#    '],
                'Q': [' |#| ', '#   #', '#   #', ' |##|', '    |'],
                'R': ['|##| ', '#   #', '|##| ', '#  | ', '#   #'],
                'S': [' |#| ', '#    ', ' |#| ', '    #', ' |#| '],
                'T': ['|###|', '  #  ', '  #  ', '  #  ', '  #  '],
                'U': ['#   #', '#   #', '#   #', '#   #', ' |#| '],
                'V': ['#   #', '#   #', '#   #', ' # # ', '  #  '],
                'W': ['#   #', '#   #', '# # #', '## ##', '#   #'],
                'X': ['#   #', ' # # ', '  #  ', ' # # ', '#   #'],
                'Y': ['#   #', ' # # ', '  #  ', '  #  ', '  #  '],
                'Z': ['|###|', '   # ', '  #  ', ' #   ', '|###|']
            }
        };

        // Tech (futuristic)
        fonts.tech = {
            name: 'tech',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': [' [?] ', ' [?] ', '     ', ' [?] ', '     '],
                '0': ['[###]', '#   #', '#   #', '#   #', '[###]'],
                '1': ['  [# ', ' [## ', '  [# ', '  [# ', '[###]'],
                '2': ['[### ', '    #', '  [  ', '  #  ', '[###]'],
                '3': ['[### ', '    #', ' [## ', '    #', '[###]'],
                '4': ['#   #', '#   #', '[####', '    #', '    #'],
                '5': ['[###]', '#    ', ' [##]', '    #', '[###]'],
                '6': ['[###]', '#    ', '[##] ', '#   #', '[###]'],
                '7': ['[###]', '    #', '   [ ', '  [  ', ' [   '],
                '8': ['[###]', '#   #', '[###]', '#   #', '[###]'],
                '9': ['[###]', '#   #', '[####', '    #', '[###]'],
                'A': [' [#] ', ' # # ', '[###]', '#   #', '#   #'],
                'B': ['[##]', '#   #', '[##]', '#   #', '[##]'],
                'C': [' [#] ', '#    ', '#    ', '#    ', ' [#] '],
                'D': ['[##]', '#   #', '#   #', '#   #', '[##]'],
                'E': ['[###]', '#    ', '[##]', '#    ', '[###]'],
                'F': ['[###]', '#    ', '[##]', '#    ', '#    '],
                'G': [' [#] ', '#    ', '# [#]', '#   #', ' [#] '],
                'H': ['#   #', '#   #', '[###]', '#   #', '#   #'],
                'I': ['[###]', '  #  ', '  #  ', '  #  ', '[###]'],
                'J': ['[###]', '   # ', '   # ', '#  # ', ' [#] '],
                'K': ['#   #', '#  [ ', '[#   ', '#  [ ', '#   #'],
                'L': ['#    ', '#    ', '#    ', '#    ', '[###]'],
                'M': ['#   #', '## ##', '# # #', '#   #', '#   #'],
                'N': ['#   #', '##  #', '# # #', '#  ##', '#   #'],
                'O': [' [#] ', '#   #', '#   #', '#   #', ' [#] '],
                'P': ['[##]', '#   #', '[##]', '#    ', '#    '],
                'Q': [' [#] ', '#   #', '#   #', ' [##]', '    #'],
                'R': ['[##]', '#   #', '[##]', '#  [ ', '#   #'],
                'S': [' [#] ', '#    ', ' [#] ', '    #', ' [#] '],
                'T': ['[###]', '  #  ', '  #  ', '  #  ', '  #  '],
                'U': ['#   #', '#   #', '#   #', '#   #', ' [#] '],
                'V': ['#   #', '#   #', '#   #', ' # # ', '  #  '],
                'W': ['#   #', '#   #', '# # #', '## ##', '#   #'],
                'X': ['#   #', ' # # ', '  #  ', ' # # ', '#   #'],
                'Y': ['#   #', ' # # ', '  #  ', '  #  ', '  #  '],
                'Z': ['[###]', '   # ', '  #  ', ' #   ', '[###]']
            }
        };

        // Gothic (medieval/dark)
        fonts.gothic = {
            name: 'gothic',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': [' |?| ', '  ?  ', '     ', '  ?  ', ' |_| '],
                '0': [' |#| ', '#   #', '#   #', '#   #', ' |#| '],
                '1': ['  |  ', ' ||  ', '  |  ', '  |  ', ' _|_ '],
                '2': [' |#| ', '    #', '  |  ', '  #  ', '  |# '],
                '3': [' |#| ', '    #', ' |#| ', '    #', ' |#| '],
                '4': [' # | ', '#  | ', ' _||_', '    | ', '    | '],
                '5': [' |# | ', '|    ', ' |## ', '    #', ' |## '],
                '6': [' |## ', '|    ', ' |##|', '#   #', ' |##|'],
                '7': [' |##|', '    #', '   | ', '  |  ', ' |   '],
                '8': [' |#| ', '#   #', ' |#| ', '#   #', ' |#| '],
                '9': [' |#| ', '#   #', ' _##|', '    #', ' |##|'],
                'A': [' |#| ', ' # # ', ' ### ', '#   #', '#   #'],
                'B': [' |## ', '#   #', ' |## ', '#   #', ' |##|'],
                'C': [' |## ', '#    ', '|    ', '#    ', ' |##|'],
                'D': [' |## ', '#   #', '|   #', '#   #', ' |##|'],
                'E': [' |## ', '|    ', ' |#  ', '|    ', ' |##|'],
                'F': [' |## ', '|    ', ' |#  ', '|    ', '|    '],
                'G': [' |## ', '|    ', '| _##', '#   #', ' |##|'],
                'H': ['|   |', '#   #', ' ___ ', '#   #', '#   #'],
                'I': [' |## ', '  |  ', '  |  ', '  |  ', ' |##|'],
                'J': [' |##|', '   # ', '   # ', '|  # ', ' |## '],
                'K': ['|   #', '|  | ', ' |   ', '|  | ', '|   #'],
                'L': ['|    ', '|    ', '|    ', '|    ', ' |###'],
                'M': ['|   |', '## ##', '# # #', '#   #', '#   #'],
                'N': ['|   #', '##  #', '# # #', '#  ##', '#   #'],
                'O': [' |#| ', '#   #', '#   #', '#   #', ' |#| '],
                'P': [' |## ', '#   #', ' |## ', '|    ', '|    '],
                'Q': [' |#| ', '#   #', '#   #', ' |##|', '    #'],
                'R': [' |## ', '#   #', ' |## ', '|  ##', '|   #'],
                'S': [' |## ', '|    ', ' |#| ', '    #', ' |## '],
                'T': [' |## ', '  |  ', '  |  ', '  |  ', '  |  '],
                'U': ['|   |', '#   #', '#   #', '#   #', ' |#| '],
                'V': ['#   #', '#   #', '#   #', ' # # ', '  #  '],
                'W': ['#   #', '#   #', '# # #', '## ##', '#   #'],
                'X': ['#   #', ' # # ', '  #  ', ' # # ', '#   #'],
                'Y': ['|   |', ' # # ', '  #  ', '  #  ', '  |  '],
                'Z': [' |## ', '   # ', '  #  ', ' #   ', ' |##|']
            }
        };

        // Neon (bright/electric)
        fonts.neon = {
            name: 'neon',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': [' *** ', '  *  ', '  *  ', '     ', '  *  '],
                '0': [' *** ', '*   *', '*   *', '*   *', ' *** '],
                '1': ['  *  ', ' **  ', '  *  ', '  *  ', ' *** '],
                '2': [' *** ', '    *', '  *  ', '  *  ', ' *** '],
                '3': [' *** ', '    *', ' **  ', '    *', ' *** '],
                '4': ['*   *', '*   *', ' ****', '    *', '    *'],
                '5': [' *** ', '*    ', ' *** ', '    *', ' *** '],
                '6': [' *** ', '*    ', ' *** ', '*   *', ' *** '],
                '7': [' *** ', '    *', '   * ', '  *  ', ' *   '],
                '8': [' *** ', '*   *', ' *** ', '*   *', ' *** '],
                '9': [' *** ', '*   *', ' ****', '    *', ' *** '],
                'A': [' *** ', '*   *', ' ****', '*   *', '*   *'],
                'B': [' *** ', '*   *', ' *** ', '*   *', ' *** '],
                'C': [' *** ', '*    ', '*    ', '*    ', ' *** '],
                'D': [' *** ', '*   *', '*   *', '*   *', ' *** '],
                'E': [' *** ', '*    ', ' *** ', '*    ', ' *** '],
                'F': [' *** ', '*    ', ' *** ', '*    ', '*    '],
                'G': [' *** ', '*    ', '*  **', '*   *', ' *** '],
                'H': ['*   *', '*   *', ' ****', '*   *', '*   *'],
                'I': [' *** ', '  *  ', '  *  ', '  *  ', ' *** '],
                'J': [' *** ', '   * ', '   * ', '*  * ', ' **  '],
                'K': ['*   *', '*  * ', '***  ', '*  * ', '*   *'],
                'L': ['*    ', '*    ', '*    ', '*    ', ' *** '],
                'M': ['*   *', '** **', '* * *', '*   *', '*   *'],
                'N': ['*   *', '**  *', '* * *', '*  **', '*   *'],
                'O': [' ### ', '*   *', '*   *', '*   *', ' ### '],
                'P': [' *** ', '*   *', ' *** ', '*    ', '*    '],
                'Q': [' *** ', '*   *', '*   *', ' ****', '    *'],
                'R': [' *** ', '*   *', ' *** ', '*  * ', '*   *'],
                'S': [' *** ', '*    ', ' *** ', '    *', ' *** '],
                'T': [' *** ', '  *  ', '  *  ', '  *  ', '  *  '],
                'U': ['*   *', '*   *', '*   *', '*   *', ' *** '],
                'V': ['*   *', '*   *', '*   *', ' * * ', '  *  '],
                'W': ['*   *', '*   *', '* * *', '** **', '*   *'],
                'X': ['*   *', ' * * ', '  *  ', ' * * ', '*   *'],
                'Y': ['*   *', ' * * ', '  *  ', '  *  ', '  *  '],
                'Z': [' *** ', '   * ', '  *  ', ' *   ', ' *** ']
            }
        };

        // Funky (playful/distorted)
        fonts.funky = {
            name: 'funky',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': [' [?] ', ' (?)  ', '      ', ' [?] ', '      '],
                '0': ['(###)', '(   )', '(   )', '(   )', '(###)'],
                '1': [' (~) ', '(~~) ', '  ~  ', '  ~  ', '(~~~)'],
                '2': ['(###)', '    ~', '  ~~', '  ~  ', '(~~~)'],
                '3': ['(###)', '    ~', ' (~~ ', '    ~', '(###)'],
                '4': ['~   ~', '~   ~', ' ~~~~', '    ~', '    ~'],
                '5': ['(~~~)', '~    ', ' (##)', '    ~', '(###)'],
                '6': ['(###)', '~    ', '(~~~)', '~   ~', '(###)'],
                '7': ['(###)', '    ~', '   ~ ', '  ~  ', ' ~   '],
                '8': ['(###)', '~   ~', ' (##)', '~   ~', '(###)'],
                '9': ['(###)', '~   ~', ' (###', '    ~', '(###)'],
                'A': [' (~) ', ' ~ ~ ', '(~~~)', '~   ~', '~   ~'],
                'B': ['(~~)', '~   ~', '(~~)', '~   ~', '(~~)'],
                'C': [' (##)', '~    ', '~    ', '~    ', ' (##)'],
                'D': ['(~~)', '~   ~', '~   ~', '~   ~', '(~~)'],
                'E': ['(###)', '~    ', '(~~~ ', '~    ', '(###)'],
                'F': ['(###)', '~    ', '(~~~ ', '~    ', '#    '],
                'G': [' (##)', '~    ', '~ (##', '~   ~', ' (##)'],
                'H': ['~   ~', '~   ~', '(~~~)', '~   ~', '~   ~'],
                'I': ['(###)', '  ~  ', '  ~  ', '  ~  ', '(###)'],
                'J': ['(###)', '   ~ ', '   ~ ', '~  ~ ', ' (## '],
                'K': ['~   ~', '  ~~ ', '(~   ', '  ~~ ', '~   ~'],
                'L': ['~    ', '~    ', '~    ', '~    ', '(###)'],
                'M': ['~   ~', '~~ ~~', '~ ~ ~', '~   ~', '~   ~'],
                'N': ['~   ~', '~~  ~', '~ ~ ~', '~  ~~', '~   ~'],
                'O': [' (##)', '~   ~', '~   ~', '~   ~', ' (##)'],
                'P': ['(~~)', '~   ~', '(~~)', '~    ', '~    '],
                'Q': [' (##)', '~   ~', '~   ~', ' (##)', '    ~'],
                'R': ['(~~)', '~   ~', '(~~)', '~  ~~', '~   ~'],
                'S': [' (##)', '~    ', ' (##)', '    ~', ' (##)'],
                'T': ['(###)', '  ~  ', '  ~  ', '  ~  ', '  ~  '],
                'U': ['~   ~', '~   ~', '~   ~', '~   ~', ' (##)'],
                'V': ['~   ~', '~   ~', '~   ~', ' ~ ~ ', '  ~  '],
                'W': ['~   ~', '~   ~', '~ ~ ~', '~~ ~~', '~   ~'],
                'X': ['~   ~', ' ~ ~ ', '  ~  ', ' ~ ~ ', '~   ~'],
                'Y': ['~   ~', ' ~ ~ ', '  ~  ', '  ~  ', '  ~  '],
                'Z': ['(###)', '   ~ ', '  ~  ', ' ~   ', '(###)']
            }
        };

        // Wave (undulating)
        fonts.wave = {
            name: 'wave',
            height: 5,
            glyphs: {
                ' ': ['     ', '     ', '     ', '     ', '     '],
                '?': ['  ~  ', '  ~  ', '     ', '  ~  ', '     '],
                '0': [' ~~~  ', '~   ~ ', '~   ~', '~   ~', ' ~~~  '],
                '1': ['   ~ ', '  ~~ ', '   ~ ', '   ~ ', '  ~~~ '],
                '2': [' ~~~ ', '~   ~', '    ~', '  ~  ', '  ~~~~ '],
                '3': [' ~~~ ', '~   ~', '   ~~ ', '~   ~', ' ~~~ '],
                '4': ['~   ~', '~   ~', ' ~~~~', '    ~', '    ~'],
                '5': [' ~~~~ ', '~    ', ' ~~~ ', '    ~', ' ~~~  '],
                '6': [' ~~~ ', '~    ', ' ~~~~ ', '~   ~', ' ~~~ '],
                '7': [' ~~~~ ', '    ~', '   ~ ', '  ~  ', ' ~   '],
                '8': [' ~~~ ', '~   ~', ' ~~~ ', '~   ~', ' ~~~ '],
                '9': [' ~~~ ', '~   ~', ' ~~~~', '    ~', ' ~~~ '],
                'A': ['  ~  ', ' ~ ~ ', '~   ~', ' ~~~~ ', '~   ~'],
                'B': [' ~~~ ', '~   ~', ' ~~~ ', '~   ~', ' ~~~ '],
                'C': [' ~~~ ', '~    ', '~    ', '~    ', ' ~~~ '],
                'D': [' ~~~ ', '~   ~', '~   ~', '~   ~', ' ~~~ '],
                'E': [' ~~~~ ', '~    ', ' ~~~ ', '~    ', ' ~~~~ '],
                'F': [' ~~~~ ', '~    ', ' ~~~ ', '~    ', '~    '],
                'G': [' ~~~ ', '~    ', '~  ~~ ', '~   ~', ' ~~~ '],
                'H': ['~   ~', '~   ~', ' ~~~~', '~   ~', '~   ~'],
                'I': [' ~~~ ', '  ~  ', '  ~  ', '  ~  ', ' ~~~ '],
                'J': [' ~~~ ', '   ~ ', '   ~ ', '~  ~ ', ' ~~  '],
                'K': ['~   ~', '  ~~ ', ' ~   ', '  ~~ ', '~   ~'],
                'L': ['~    ', '~    ', '~    ', '~    ', ' ~~~~ '],
                'M': ['~   ~', '~~ ~~', '~ ~ ~', '~   ~', '~   ~'],
                'N': ['~   ~', '~~  ~', '~ ~ ~', '~  ~~', '~   ~'],
                'O': [' (##)', '~   ~', '~   ~', '~   ~', ' (##)'],
                'P': [' (##)', '~   ~', ' (##)', '~    ', '~    '],
                'Q': [' (##)', '~   ~', '~   ~', ' (##)', '    ~'],
                'R': [' (##)', '~   ~', ' (##)', '~  ~~ ', '~   ~'],
                'S': [' (##)', '~    ', ' (##)', '    ~', ' (##)'],
                'T': [' ~~~~ ', '  ~  ', '  ~  ', '  ~  ', '  ~  '],
                'U': ['~   ~', '~   ~', '~   ~', '~   ~', ' (##)'],
                'V': ['~   ~', '~   ~', '~   ~', ' ~ ~ ', '  ~  '],
                'W': ['~   ~', '~   ~', '~ ~ ~', '~~ ~~', '~   ~'],
                'X': ['~   ~', ' ~ ~ ', '  ~  ', ' ~ ~ ', '~   ~'],
                'Y': ['~   ~', ' ~ ~ ', '  ~  ', '  ~  ', '  ~  '],
                'Z': [' ~~~~ ', '   ~ ', '  ~  ', ' ~   ', ' ~~~~ ']
            }
        };

        this.fonts = fonts;
    }

    _makeBlockVariant(glyphs) {
        const out = {};
        for (const k of Object.keys(glyphs)) {
            out[k] = glyphs[k].map(row => row.replace(/#/g, '█'));
        }
        return out;
    }

    getFont(name) {
        this.ensureFonts();
        const key = (name || 'standard').toLowerCase();
        return this.fonts[key] || this.fonts.standard;
    }

    getAvailableFonts() {
        return ['standard', 'block', 'mini', 'small', 'bubble', '3d', 'outlined', 'italic', 'shadow', 'retro', 'tech', 'gothic', 'neon', 'funky', 'wave'];
    }
}

// Renderer with flexible error recovery
const USE_ASCII_RENDERER = true;
const DEBUG_MODE = false;  // Set to true for detailed logs

class ASCIIRenderer {
    constructor() {
        this.lastError = null;
        this.fallbackChar = '?';
        this.maxLineLength = 500;  // Prevent extremely long lines
        this.maxLines = 100;       // Prevent massive outputs
    }

    log(message) {
        if (DEBUG_MODE) console.log(`[Renderer] ${message}`);
    }

    renderTextWithFont(text, font) {
        try {
            this.lastError = null;
            const input = String(text || '').trim();

            // Input validation
            if (!input) {
                return ''; // Empty input returns empty
            }

            if (!this.validateFont(font)) {
                throw new Error('Invalid font object structure');
            }

            if (!USE_ASCII_RENDERER) {
                this.log('Fallback: Echo mode enabled');
                return input;
            }

            // Sanitize and truncate input
            const sanitized = this.sanitizeInput(input);
            const lines = sanitized.split('\n');

            if (lines.length > this.maxLines) {
                this.log(`Input truncated: ${lines.length} lines → ${this.maxLines}`);
                lines.length = this.maxLines;
            }

            // Render each line
            const outLines = [];
            for (let i = 0; i < lines.length; i++) {
                try {
                    const renderedLine = this.renderLine(lines[i], font);
                    outLines.push(renderedLine);
                } catch (lineError) {
                    this.log(`Warning: Line ${i + 1} failed: ${lineError.message}`);
                    // Add fallback line with character substitution
                    outLines.push(this.createFallbackLine(lines[i], font));
                }
            }

            return outLines.join('\n');
        } catch (error) {
            this.lastError = error;
            console.error('❌ Renderer fatal error:', error);
            // Return input as-is on total failure
            return String(text || '').trim();
        }
    }

    validateFont(font) {
        if (!font || typeof font !== 'object') {
            return false;
        }
        if (!font.glyphs || typeof font.glyphs !== 'object') {
            return false;
        }
        if (!Number.isInteger(font.height) || font.height < 1 || font.height > 10) {
            return false;
        }
        return true;
    }

    sanitizeInput(input) {
        // Remove control characters but preserve newlines
        return input
            .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '')
            .substring(0, 10000); // Hard limit
    }

    renderLine(line, font) {
        if (!line || line.trim().length === 0) {
            return ''; // Empty line
        }

        const rowBuffers = Array.from({ length: font.height }, () => []);
        const chars = line.toUpperCase().split('');
        let charCount = 0;

        for (const ch of chars) {
            try {
                const glyph = font.glyphs[ch] || font.glyphs[this.fallbackChar];

                if (!glyph) {
                    throw new Error(`No glyph for '${ch}' or fallback`);
                }

                if (!Array.isArray(glyph) || glyph.length !== font.height) {
                    throw new Error(`Malformed glyph for '${ch}': expected ${font.height} rows, got ${glyph?.length || 0}`);
                }

                // Add glyph rows
                for (let r = 0; r < font.height; r++) {
                    const row = String(glyph[r] || '');
                    if (!row) {
                        throw new Error(`Empty row ${r} in glyph for '${ch}'`);
                    }
                    rowBuffers[r].push(row);
                }

                // Column gap
                for (let r = 0; r < font.height; r++) {
                    rowBuffers[r].push(' ');
                }

                charCount++;
            } catch (charError) {
                this.log(`Char error for '${ch}': ${charError.message}`);
                // Fallback: add placeholder glyph
                for (let r = 0; r < font.height; r++) {
                    rowBuffers[r].push('?');
                }
                for (let r = 0; r < font.height; r++) {
                    rowBuffers[r].push(' ');
                }
            }
        }

        // Build output rows
        const outputRows = [];
        for (let r = 0; r < font.height; r++) {
            const row = rowBuffers[r].join('').replace(/\s+$/g, '');
            
            // Check line length
            if (row.length > this.maxLineLength) {
                this.log(`Line ${r + 1} truncated: ${row.length} → ${this.maxLineLength}`);
                outputRows.push(row.substring(0, this.maxLineLength));
            } else {
                outputRows.push(row);
            }
        }

        return outputRows.join('\n');
    }

    createFallbackLine(line, font) {
        // When a line fails, create a simple fallback representation
        const safeChars = line
            .toUpperCase()
            .replace(/[^A-Z0-9\s]/g, '?')
            .substring(0, 50);
        
        const rows = [];
        for (let r = 0; r < font.height; r++) {
            rows.push(r === Math.floor(font.height / 2) ? `[${safeChars}]` : '');
        }
        return rows.join('\n');
    }

    getLastError() {
        return this.lastError;
    }

    clearError() {
        this.lastError = null;
    }
}

// Poetry Formatter - handles poem formatting with borders
class PoetryFormatter {
    constructor() {
        this.borderStyles = {
            'none': { top: '', middle: '', bottom: '', left: '', right: '' },
            'box': { top: '━', middle: '─', bottom: '━', left: '│', right: '│' },
            'double': { top: '═', middle: '═', bottom: '═', left: '║', right: '║' },
            'rounded': { top: '─', middle: '─', bottom: '─', left: '│', right: '│' },
            'stars': { top: '✦', middle: '✦', bottom: '✦', left: '✦', right: '✦' },
            'dashes': { top: '─', middle: '─', bottom: '─', left: '─', right: '─' },
            'thick': { top: '█', middle: '█', bottom: '█', left: '█', right: '█' }
        };
        this.maxLineWidth = 80;
    }

    formatPoem(text, borderStyle = 'none', padding = 2) {
        try {
            const lines = text.trim().split('\n');
            const border = this.borderStyles[borderStyle] || this.borderStyles.none;
            
            // Find the longest line
            let maxWidth = Math.max(...lines.map(l => l.length));
            maxWidth = Math.min(maxWidth + (padding * 2), this.maxLineWidth);

            // Create formatted output
            const output = [];

            // Top border
            if (border.top) {
                output.push(border.top.repeat(maxWidth + 4));
            }

            // Poem lines with padding
            for (const line of lines) {
                const paddedLine = line.padEnd(maxWidth);
                const formatted = `${border.left} ${paddedLine.substring(0, maxWidth)} ${border.right}`;
                output.push(formatted);
            }

            // Bottom border
            if (border.bottom) {
                output.push(border.bottom.repeat(maxWidth + 4));
            }

            return output.join('\n');
        } catch (error) {
            console.error('❌ Poetry formatting error:', error);
            // Fallback: just return the text with simple padding
            return text.split('\n').map(line => `  ${line}  `).join('\n');
        }
    }
}

// Color utilities
const colorCodes = {
    'red': '\x1b[31m',
    'green': '\x1b[32m',
    'yellow': '\x1b[33m',
    'blue': '\x1b[34m',
    'magenta': '\x1b[35m',
    'cyan': '\x1b[36m',
    'white': '\x1b[37m',
    'reset': '\x1b[0m'
};

function applyColorClass(color) {
    if (color && color !== 'none') {
        return `color-${color}`;
    }
    return '';
}

// Main app with modes
class SimpleASCIIArt {
    constructor() {
        this.fontManager = null;
        this.asciiRenderer = null;
        this.poetryFormatter = null;
        this.isGenerating = false;
        this.lastValidState = null;
        this.generationTimeout = 5000;
        this.fontChangeDelay = 300;
        this.fontChangeTimer = null;
        this.currentMode = 'text';  // 'text', 'poetry', or 'ai'
        this.settings = {
            apiUrl: 'http://localhost:8000',
            apiKey: '',
            model: 'mistral',
            temperature: 0.7,
            maxTokens: 1000
        };
        this.init();
    }

    async init() {
        console.log('🚀 Simple ASCII Art Generator - Initializing...');

        try {
            this.fontManager = new FontManager();
            this.asciiRenderer = new ASCIIRenderer();
            this.poetryFormatter = new PoetryFormatter();
            this.cacheDOM();
            this.validateDOM();
            this.syncFontSelect();
            this.attachEventListeners();
            this.setupModeButtons();
            this.setDefaultFont();
            console.log('✅ Simple ASCII Art Generator - Ready!');
            console.log('💡 Enter text and click "Generate ASCII Art" to begin');
        } catch (error) {
            console.error('❌ Initialization failed:', error);
            this.showError('Failed to initialize application. Please refresh the page.');
            throw error;
        }
    }

    cacheDOM() {
        this.textInput = document.getElementById('text-input');
        this.fontSelect = document.getElementById('font-select');
        this.generateBtn = document.getElementById('generate-main');
        this.output = document.getElementById('ascii-output');
        this.colorSelect = document.getElementById('color-select');
        this.borderSelect = document.getElementById('border-select');
        this.poetryColorSelect = document.getElementById('poetry-color-select');
        this.colorGroup = document.getElementById('color-group');
        this.borderGroup = document.getElementById('border-group');
        this.poetryColorGroup = document.getElementById('poetry-color-group');
        this.textInputLabel = document.getElementById('text-input-label');
        this.inputTitle = document.getElementById('input-title');
        this.modeTextBtn = document.getElementById('mode-text');
        this.modePoetryBtn = document.getElementById('mode-poetry');
        this.modeAiBtn = document.getElementById('mode-ai');
        this.clearOutputBtn = document.getElementById('clear-output-btn');
        this.aiPrompt = document.getElementById('ai-prompt');
        this.aiPromptGroup = document.getElementById('ai-prompt-group');
        this.textInputGroup = document.getElementById('text-input-group');
        
        // Settings elements
        this.settingsBtn = document.getElementById('settings-btn');
        this.settingsModal = document.getElementById('settings-modal');
        this.closeSettingsBtn = document.getElementById('close-settings-btn');
        this.settingsApiUrl = document.getElementById('settings-api-url');
        this.settingsApiKey = document.getElementById('settings-api-key');
        this.settingsModel = document.getElementById('settings-model');
        this.settingsTemp = document.getElementById('settings-temp');
        this.settingsTokens = document.getElementById('settings-tokens');
        this.testApiBtn = document.getElementById('test-api-btn');
        this.saveApiBtn = document.getElementById('save-api-btn');

        if (!this.textInput || !this.fontSelect || !this.generateBtn || !this.output) {
            throw new Error('Required DOM elements not found');
        }

        console.log('📋 DOM elements cached');
    }

    validateDOM() {
        const checks = [
            { el: this.textInput, name: 'text input' },
            { el: this.fontSelect, name: 'font selector' },
            { el: this.generateBtn, name: 'generate button' },
            { el: this.output, name: 'output area' }
        ];

        for (const check of checks) {
            if (!check.el || typeof check.el.addEventListener !== 'function') {
                throw new Error(`DOM element "${check.name}" is not valid`);
            }
        }

        console.log('✅ DOM elements validated');
    }

    setupModeButtons() {
        if (this.modeTextBtn) {
            this.modeTextBtn.addEventListener('click', () => this.setMode('text'));
        }
        if (this.modePoetryBtn) {
            this.modePoetryBtn.addEventListener('click', () => this.setMode('poetry'));
        }
        if (this.modeAiBtn) {
            this.modeAiBtn.addEventListener('click', () => this.setMode('ai'));
        }
        if (this.clearOutputBtn) {
            this.clearOutputBtn.addEventListener('click', () => this.clearOutput());
        }
    }

    setMode(mode) {
        if (mode === this.currentMode) return;

        this.currentMode = mode;
        console.log(`🔄 Switched to ${mode} mode`);

        // Update UI - Use data attributes to control visibility without breaking layout
        if (mode === 'text') {
            this.modeTextBtn?.classList.add('active');
            this.modePoetryBtn?.classList.remove('active');
            this.modeAiBtn?.classList.remove('active');
            this.inputTitle.textContent = 'ASCII Art Generator';
            this.textInputLabel.textContent = 'Enter your text:';
            
            if (this.textInputGroup) this.textInputGroup.style.display = 'grid';
            if (this.aiPromptGroup) this.aiPromptGroup.style.display = 'none';
            if (this.apiKeyGroup) this.apiKeyGroup.style.display = 'none';
            if (this.apiUrlGroup) this.apiUrlGroup.style.display = 'none';
            if (this.colorGroup) this.colorGroup.style.display = 'block';
            if (this.borderGroup) this.borderGroup.style.display = 'none';
            if (this.poetryColorGroup) this.poetryColorGroup.style.display = 'none';
            if (this.fontSelect) this.fontSelect.style.display = 'block';
        } else if (mode === 'poetry') {
            this.modePoetryBtn?.classList.add('active');
            this.modeTextBtn?.classList.remove('active');
            this.modeAiBtn?.classList.remove('active');
            this.inputTitle.textContent = 'Poetry Formatter';
            this.textInputLabel.textContent = 'Enter your poem:';
            
            if (this.textInputGroup) this.textInputGroup.style.display = 'grid';
            if (this.aiPromptGroup) this.aiPromptGroup.style.display = 'none';
            if (this.apiKeyGroup) this.apiKeyGroup.style.display = 'none';
            if (this.apiUrlGroup) this.apiUrlGroup.style.display = 'none';
            if (this.colorGroup) this.colorGroup.style.display = 'none';
            if (this.borderGroup) this.borderGroup.style.display = 'block';
            if (this.poetryColorGroup) this.poetryColorGroup.style.display = 'block';
            if (this.fontSelect) this.fontSelect.style.display = 'block';
        } else if (mode === 'ai') {
            this.modeAiBtn?.classList.add('active');
            this.modeTextBtn?.classList.remove('active');
            this.modePoetryBtn?.classList.remove('active');
            this.inputTitle.textContent = 'AI ASCII Art Generator';
            
            if (this.textInputGroup) this.textInputGroup.style.display = 'none';
            if (this.aiPromptGroup) this.aiPromptGroup.style.display = 'grid';
            if (this.apiKeyGroup) this.apiKeyGroup.style.display = 'grid';
            if (this.apiUrlGroup) this.apiUrlGroup.style.display = 'grid';
            if (this.colorGroup) this.colorGroup.style.display = 'block';
            if (this.borderGroup) this.borderGroup.style.display = 'none';
            if (this.poetryColorGroup) this.poetryColorGroup.style.display = 'none';
            if (this.fontSelect) this.fontSelect.style.display = 'block';
        }

        // Regenerate if input exists
        const hasInput = this.currentMode === 'ai' ? 
            this.aiPrompt?.value.trim() : 
            this.textInput?.value.trim();
        if (hasInput) {
            this.handleGenerate();
        }
    }

    syncFontSelect() {
        if (!this.fontSelect) return;
        try {
            const fonts = this.fontManager.getAvailableFonts();
            this.fontSelect.innerHTML = '';
            for (const name of fonts) {
                const opt = document.createElement('option');
                opt.value = name;
                opt.textContent = name.charAt(0).toUpperCase() + name.slice(1);
                this.fontSelect.appendChild(opt);
            }
            console.log(`📝 Font dropdown synced: ${fonts.length} fonts`);
        } catch (error) {
            console.error('❌ Failed to sync font selector:', error);
            this.showError('Font selector initialization failed');
        }
    }

    attachEventListeners() {
        try {
            // Generate button click
            this.generateBtn.addEventListener('click', () => {
                this.handleGenerate();
            });

            // Enter key in text input
            this.textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && e.ctrlKey) {
                    this.handleGenerate();
                }
            });

            // Font selection change (debounced)
            this.fontSelect.addEventListener('change', () => {
                this.handleFontChange();
            });

            this.colorSelect?.addEventListener('change', () => {
                if (this.textInput.value.trim()) {
                    this.handleGenerate();
                }
            });

            this.borderSelect?.addEventListener('change', () => {
                if (this.textInput.value.trim()) {
                    this.handleGenerate();
                }
            });

            this.poetryColorSelect?.addEventListener('change', () => {
                if (this.textInput.value.trim()) {
                    this.handleGenerate();
                }
            });

            // Settings modal handlers
            this.settingsBtn?.addEventListener('click', () => this.openSettings());
            this.closeSettingsBtn?.addEventListener('click', () => this.closeSettings());
            this.settingsModal?.addEventListener('click', (e) => {
                if (e.target === this.settingsModal) this.closeSettings();
            });

            // Settings tab switcher
            document.querySelectorAll('.settings-tab-btn').forEach(btn => {
                btn.addEventListener('click', (e) => this.switchSettingsTab(e.target.dataset.tab));
            });

            // Settings save/test buttons
            this.saveApiBtn?.addEventListener('click', () => this.saveSettings());
            this.testApiBtn?.addEventListener('click', () => this.testAPIConnection());
            document.getElementById('auto-detect-btn')?.addEventListener('click', () => this.autoDetectServices());

            console.log('🔗 Event listeners attached');
        } catch (error) {
            console.error('❌ Failed to attach event listeners:', error);
            throw error;
        }
    }

    openSettings() {
        this.loadSettings();
        if (this.settingsModal) this.settingsModal.style.display = 'flex';
        console.log('⚙️ Settings opened');
    }

    closeSettings() {
        if (this.settingsModal) this.settingsModal.style.display = 'none';
        console.log('⚙️ Settings closed');
    }

    switchSettingsTab(tabName) {
        // Hide all tabs
        document.querySelectorAll('.settings-tab-content').forEach(tab => {
            tab.classList.remove('active');
        });
        document.querySelectorAll('.settings-tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });

        // Show selected tab
        const tabElement = document.getElementById(`${tabName}-tab`);
        const btnElement = document.querySelector(`[data-tab="${tabName}"]`);
        if (tabElement) tabElement.classList.add('active');
        if (btnElement) btnElement.classList.add('active');
    }

    loadSettings() {
        const saved = localStorage.getItem('asciiArtSettings');
        if (saved) {
            this.settings = { ...this.settings, ...JSON.parse(saved) };
        }

        // Update form fields
        if (this.settingsApiUrl) this.settingsApiUrl.value = this.settings.apiUrl;
        if (this.settingsApiKey) this.settingsApiKey.value = this.settings.apiKey;
        if (this.settingsModel) this.settingsModel.value = this.settings.model;
        if (this.settingsTemp) this.settingsTemp.value = this.settings.temperature;
        if (this.settingsTokens) this.settingsTokens.value = this.settings.maxTokens;
    }

    saveSettings() {
        this.settings = {
            apiUrl: this.settingsApiUrl?.value || 'http://localhost:8000',
            apiKey: this.settingsApiKey?.value || '',
            model: this.settingsModel?.value || 'mistral',
            temperature: parseFloat(this.settingsTemp?.value) || 0.7,
            maxTokens: parseInt(this.settingsTokens?.value) || 1000
        };

        localStorage.setItem('asciiArtSettings', JSON.stringify(this.settings));
        this.showNotification('💾 Settings saved successfully!', 'success');
        console.log('💾 Settings saved:', this.settings);
    }

    async testAPIConnection() {
        try {
            this.testApiBtn.disabled = true;
            this.testApiBtn.textContent = '🔄 Testing...';

            const apiUrl = this.settingsApiUrl?.value;
            const apiKey = this.settingsApiKey?.value;

            if (!apiUrl || !apiKey) {
                this.showNotification('⚠️ API URL and Key are required', 'warning');
                return;
            }

            // Show connection log
            this.clearConnectionLog();
            const connectionLog = document.getElementById('connection-log');
            if (connectionLog) connectionLog.style.display = 'block';

            const container = document.getElementById('api-status-container');
            if (container) container.style.display = 'flex';

            this.addLog('🔍 Testing connection...', 'info');

            // Step 1: Check if proxy is running
            this.addLog('[1/3] Checking proxy server...', 'info');
            try {
                const proxyCheck = await fetch('http://localhost:8001/api/proxy', {
                    method: 'OPTIONS'
                });
                this.updateStatusDot('proxy-status-dot', 'connected', 'Proxy: Connected ✓');
                this.addLog('✅ Proxy is running on port 8001', 'success');
            } catch (error) {
                this.updateStatusDot('proxy-status-dot', 'disconnected', 'Proxy: Disconnected ✗');
                this.addLog('❌ Proxy not detected on port 8001', 'error');
                this.addLog('💡 Run: python proxy.py in a new terminal', 'warning');
                this.showNotification('❌ Proxy server not running. Start it with: python proxy.py', 'error');
                return;
            }

            // Step 2: Check OpenWebUI
            this.addLog('[2/3] Checking OpenWebUI...', 'info');
            try {
                const webUICheck = await fetch(apiUrl, { mode: 'no-cors', method: 'HEAD' });
                this.updateStatusDot('openwebui-status', 'connected', 'OpenWebUI: Connected ✓');
                this.addLog(`✅ OpenWebUI is running at ${apiUrl}`, 'success');
            } catch (error) {
                this.updateStatusDot('openwebui-status', 'disconnected', 'OpenWebUI: Disconnected ✗');
                this.addLog(`❌ Cannot reach OpenWebUI at ${apiUrl}`, 'error');
                this.addLog('💡 Start OpenWebUI: docker run -d -p 8000:8000 ghcr.io/open-webui/open-webui:latest', 'warning');
                this.showNotification(`❌ Cannot reach OpenWebUI at ${apiUrl}`, 'error');
                return;
            }

            // Step 3: Test API key through proxy
            this.addLog('[3/3] Testing API key...', 'info');
            const testPayload = {
                url: `${apiUrl}/api/chat/completions`,
                apiKey: apiKey,
                data: {
                    model: this.settingsModel?.value || 'mistral',
                    messages: [{ role: 'user', content: 'test' }],
                    max_tokens: 10
                }
            };

            const response = await fetch('http://localhost:8001/api/proxy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(testPayload)
            });

            const responseData = await response.json();

            if (response.ok) {
                this.addLog('✅ API connection successful!', 'success');
                this.addLog('🎉 All systems ready for AI generation', 'success');
                this.showNotification('✅ All systems ready! You can now generate AI ASCII art.', 'success');
            } else {
                const errorMsg = responseData.details || responseData.error || `API error: ${response.status}`;
                this.addLog(`❌ API Error: ${errorMsg}`, 'error');
                this.showNotification(`❌ API Error: ${errorMsg}`, 'error');
            }
        } catch (error) {
            if (error.message.includes('Failed to fetch')) {
                this.updateStatusDot('proxy-status-dot', 'disconnected', 'Proxy: Disconnected ✗');
                this.addLog('❌ Cannot reach proxy server on port 8001', 'error');
                this.addLog('💡 Run: python proxy.py', 'warning');
                this.showNotification('❌ Cannot reach proxy server. Run: python proxy.py', 'error');
            } else {
                this.addLog(`❌ Test failed: ${error.message}`, 'error');
                this.showNotification(`❌ Test failed: ${error.message}`, 'error');
            }
        } finally {
            this.testApiBtn.disabled = false;
            this.testApiBtn.textContent = '🧪 Test Connection';
        }
    }

    updateProxyStatus(isConnected) {
        const statusEl = document.getElementById('proxy-status');
        const statusText = document.getElementById('proxy-status-text');
        
        if (statusEl) {
            statusEl.style.display = 'block';
            statusEl.classList.remove('connected', 'disconnected');
            
            if (isConnected) {
                statusEl.classList.add('connected');
                statusText.textContent = '🟢 Proxy Connected';
            } else {
                statusEl.classList.add('disconnected');
                statusText.textContent = '🔴 Proxy Disconnected';
            }
        }
    }

    handleFontChange() {
        if (this.fontChangeTimer) {
            clearTimeout(this.fontChangeTimer);
        }

        this.fontChangeTimer = setTimeout(() => {
            if (this.textInput.value.trim()) {
                console.log('🔄 Font changed, regenerating...');
                this.handleGenerate();
            }
        }, this.fontChangeDelay);
    }

    setDefaultFont() {
        if (this.fontSelect) {
            try {
                this.fontSelect.value = 'standard';
            } catch (error) {
                console.warn('⚠️ Failed to set default font:', error);
            }
        }
    }

    async handleGenerate() {
        if (this.isGenerating) {
            console.warn('⚠️ Generation already in progress');
            this.showNotification('⏳ Please wait, generation in progress...', 'warning');
            return;
        }

        // Determine input based on mode
        let text;
        if (this.currentMode === 'ai') {
            text = this.aiPrompt?.value?.trim();
            if (!text) {
                this.showNotification('⚠️ Please describe the ASCII art you want', 'warning');
                return;
            }
            
            // Validate API configuration
            if (!this.settings.apiKey || !this.settings.apiUrl) {
                this.showNotification('⚠️ API not configured. Click ⚙️ Settings to setup', 'warning');
                return;
            }
        } else {
            text = this.textInput?.value?.trim();
            if (!text) {
                this.showNotification('⚠️ Please enter some text', 'warning');
                return;
            }
        }

        if (text.length > 5000) {
            this.showNotification('⚠️ Text is too long (max 5000 chars)', 'warning');
            return;
        }

        try {
            this.isGenerating = true;
            this.updateButtonState();
            console.log(`⚙️ Generating ${this.currentMode}...`);

            let result;
            if (this.currentMode === 'text') {
                result = await this.generateText(text);
            } else if (this.currentMode === 'poetry') {
                result = await this.generatePoetry(text);
            } else if (this.currentMode === 'ai') {
                result = await this.generateAI(text);
            }

            this.lastValidState = result;
            this.displayOutput(result);
            console.log('✅ Generation complete');

        } catch (error) {
            console.error('❌ Generation failed:', error);
            
            if (error.message === 'Generation timeout') {
                this.showError('Generation took too long. Try shorter text.');
            } else if (error.message.includes('API')) {
                this.showError(`API Error: ${error.message}`);
            } else {
                this.showError(`Generation failed: ${error.message}`);
            }

            if (this.lastValidState) {
                console.log('🔄 Rolling back to last valid state...');
                this.displayOutput(this.lastValidState);
            }

        } finally {
            this.isGenerating = false;
            this.updateButtonState();
        }
    }

    async generateText(text) {
        try {
            const fontName = this.fontSelect?.value || 'standard';
            const available = this.fontManager.getAvailableFonts();
            const finalFont = available.includes(fontName) ? fontName : 'standard';

            const font = this.fontManager.getFont(finalFont);
            if (!this.asciiRenderer.validateFont(font)) {
                throw new Error('Font validation failed');
            }

            const ascii = this.asciiRenderer.renderTextWithFont(text, font);
            if (!ascii) {
                throw new Error('Rendering returned empty');
            }

            const color = this.colorSelect?.value || 'none';

            return {
                ascii: ascii,
                font: finalFont,
                text: text,
                color: color,
                mode: 'text',
                timestamp: Date.now(),
                success: true
            };
        } catch (error) {
            throw new Error(`Text generation error: ${error.message}`);
        }
    }

    async generatePoetry(text) {
        try {
            const borderStyle = this.borderSelect?.value || 'box';
            const color = this.poetryColorSelect?.value || 'none';
            const fontName = this.fontSelect?.value || 'standard';
            const available = this.fontManager.getAvailableFonts();
            const finalFont = available.includes(fontName) ? fontName : 'standard';
            
            // Format the poem with border
            let formatted = this.poetryFormatter.formatPoem(text, borderStyle, 1);

            // Optionally apply ASCII font rendering to poem text
            // For poetry, we'll use ASCII fonts to render the poem lines
            if (fontName !== 'standard') {
                try {
                    const font = this.fontManager.getFont(finalFont);
                    if (this.asciiRenderer.validateFont(font)) {
                        // Apply font to first line of poem for visual effect
                        const firstLine = text.split('\n')[0];
                        const asciiTitle = this.asciiRenderer.renderTextWithFont(firstLine, font);
                        formatted = asciiTitle + '\n\n' + formatted;
                    }
                } catch (e) {
                    console.warn('Could not apply font to poem:', e.message);
                    // Continue without font - fallback to plain poem
                }
            }

            return {
                ascii: formatted,
                border: borderStyle,
                color: color,
                font: finalFont,
                mode: 'poetry',
                text: text,
                timestamp: Date.now(),
                success: true
            };
        } catch (error) {
            throw new Error(`Poetry generation error: ${error.message}`);
        }
    }

    async generateAI(prompt) {
        try {
            // Check if API is configured
            if (!this.settings.apiKey) {
                const err = new Error('API Key not configured');
                err.requiresSetup = true;
                throw err;
            }

            const fontName = this.fontSelect?.value || 'standard';
            const available = this.fontManager.getAvailableFonts();
            const finalFont = available.includes(fontName) ? fontName : 'standard';
            const color = this.colorSelect?.value || 'none';

            console.log('🤖 Calling OpenWebUI API through proxy...');

            // Prepare the payload for the actual API
            const apiPayload = {
                model: this.settings.model,
                messages: [{
                    role: 'user',
                    content: `Create detailed ASCII art of: ${prompt}\n\nMake it creative, detailed, and visually impressive. Use a variety of characters for shading and texture. Keep it under 50 lines.`
                }],
                temperature: this.settings.temperature,
                max_tokens: this.settings.maxTokens
            };

            // Send through proxy
            const proxyRequest = {
                url: `${this.settings.apiUrl}/api/chat/completions`,
                apiKey: this.settings.apiKey,
                data: apiPayload
            };

            console.log('📤 Sending through proxy server...');
            const response = await fetch('http://localhost:8001/api/proxy', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(proxyRequest)
            });

            // First check if response is valid
            const contentType = response.headers.get('content-type');
            let responseData;
            
            try {
                responseData = await response.json();
            } catch (e) {
                // Response is not JSON, try to get text
                const text = await response.text();
                if (text.includes('<!DOCTYPE') || text.includes('<html')) {
                    throw new Error('API returned HTML error page - OpenWebUI may not be responding correctly');
                }
                throw new Error(`Invalid response format: ${text.substring(0, 100)}`);
            }

            if (!response.ok) {
                const errorMsg = responseData.details || responseData.error || `API error: ${response.status}`;
                throw new Error(`OpenWebUI API error: ${errorMsg}`);
            }

            let ascii = responseData.choices?.[0]?.message?.content;

            if (!ascii) {
                throw new Error('No ASCII art generated from API');
            }

            // Clean up the response (remove markdown code blocks if present)
            ascii = ascii.replace(/```(?:ascii)?\n?|\n?```/g, '').trim();

            if (!ascii) {
                throw new Error('Generated content was empty after cleanup');
            }

            console.log('✅ AI generation complete');

            return {
                ascii: ascii,
                prompt: prompt,
                font: finalFont,
                color: color,
                mode: 'ai',
                apiUrl: this.settings.apiUrl,
                timestamp: Date.now(),
                success: true
            };

        } catch (error) {
            if (error.requiresSetup) {
                throw new Error(`API not configured - Click ⚙️ to setup OpenWebUI API key`);
            }
            
            if (error.message.includes('Failed to fetch')) {
                throw new Error('Cannot reach proxy server. Make sure proxy.py is running on port 8001');
            }
            
            throw new Error(`AI generation error: ${error.message}`);
        }
    }

    displayOutput(result) {
        try {
            if (!this.output) {
                throw new Error('Output element not found');
            }

            if (!result || !result.ascii) {
                throw new Error('Invalid result object');
            }

            this.output.textContent = result.ascii;
            this.output.className = 'ascii-output';

            // Apply color class - handle rainbow specially
            if (result.color && result.color !== 'none') {
                if (result.color === 'rainbow') {
                    // Force reflow to restart animation
                    this.output.classList.remove('color-rainbow');
                    // Trigger reflow
                    void this.output.offsetWidth;
                    this.output.classList.add('color-rainbow');
                } else {
                    this.output.classList.add(`color-${result.color}`);
                }
            }

            // Apply border class for poetry
            if (result.mode === 'poetry' && result.border && result.border !== 'none') {
                this.output.classList.add(`poetry-border-${result.border}`);
                this.output.style.padding = '15px';
                this.output.style.paddingLeft = '20px';
                this.output.style.paddingRight = '20px';
            } else {
                this.output.style.padding = '10px';
            }

            this.output.setAttribute('data-mode', result.mode);
            this.output.setAttribute('data-timestamp', result.timestamp);

            console.log(`✨ Output displayed (${result.ascii.length} chars, mode: ${result.mode})`);
        } catch (error) {
            console.error('❌ Display failed:', error);
            if (this.output) {
                this.output.textContent = '';
                this.output.className = 'ascii-output error';
            }
            throw error;
        }
    }

    updateButtonState() {
        if (!this.generateBtn) return;

        try {
            this.generateBtn.disabled = this.isGenerating;
            this.generateBtn.classList.toggle('generating', this.isGenerating);

            if (this.isGenerating) {
                this.generateBtn.textContent = '⏳ Generating...';
            } else {
                this.generateBtn.textContent = '✨ Generate';
            }
        } catch (error) {
            console.error('❌ Failed to update button state:', error);
        }
    }

    showNotification(message, type = 'info') {
        const typeIcon = {
            'info': '💬',
            'warning': '⚠️',
            'error': '❌',
            'success': '✅'
        };

        const icon = typeIcon[type] || '💬';
        console.log(`${icon} ${type.toUpperCase()}: ${message}`);

        if (type === 'error' && this.output) {
            try {
                this.output.textContent = `${icon} ${message}`;
                this.output.className = 'ascii-output error';
            } catch (e) {
                console.error('Failed to show error notification:', e);
            }
        }
    }

    showError(message) {
        this.showNotification(message, 'error');
    }

    recover() {
        try {
            console.log('🔄 Attempting recovery...');
            this.isGenerating = false;
            this.updateButtonState();
            if (this.lastValidState) {
                this.displayOutput(this.lastValidState);
                console.log('✅ Recovered to last valid state');
            }
        } catch (error) {
            console.error('❌ Recovery failed:', error);
        }
    }

    clearOutput() {
        if (this.output) {
            this.output.textContent = '';
            this.output.className = 'ascii-output';
            console.log('🗑️ Output cleared');
        }
    }

    async autoDetectServices() {
        console.log('🔍 Starting auto-detection...');
        this.clearConnectionLog();
        this.addLog('🔍 Auto-detecting services...', 'info');
        
        const container = document.getElementById('api-status-container');
        if (container) container.style.display = 'flex';
        
        const connectionLog = document.getElementById('connection-log');
        if (connectionLog) connectionLog.style.display = 'block';

        try {
            // Check OpenWebUI
            this.addLog('[1/2] Checking OpenWebUI at ' + this.settingsApiUrl.value, 'info');
            const openwebuiConnected = await this.checkOpenWebUI();
            
            // Check Proxy
            this.addLog('[2/2] Checking Proxy Server...', 'info');
            const proxyConnected = await this.checkProxyServer();

            if (openwebuiConnected && proxyConnected) {
                this.addLog('✅ All services detected!', 'success');
                this.showNotification('✅ All services detected! Ready to configure API key.', 'success');
            } else {
                if (!openwebuiConnected) {
                    this.addLog('❌ OpenWebUI not found at ' + this.settingsApiUrl.value, 'error');
                }
                if (!proxyConnected) {
                    this.addLog('❌ Proxy server not running (need: python proxy.py)', 'error');
                }
            }
        } catch (error) {
            this.addLog(`❌ Error: ${error.message}`, 'error');
        }
    }

    async checkOpenWebUI() {
        try {
            const url = this.settingsApiUrl.value;
            const response = await fetch(url, { method: 'HEAD', mode: 'no-cors' });
            
            this.updateStatusDot('openwebui-status', 'connected', 'OpenWebUI: Connected ✓');
            this.addLog('✅ OpenWebUI is running', 'success');
            return true;
        } catch (error) {
            this.updateStatusDot('openwebui-status', 'disconnected', 'OpenWebUI: Not running ✗');
            this.addLog(`❌ OpenWebUI connection failed: ${error.message}`, 'error');
            return false;
        }
    }

    async checkProxyServer() {
        try {
            const response = await fetch('http://localhost:8001/api/proxy', {
                method: 'OPTIONS',
                timeout: 5000
            });
            
            this.updateStatusDot('proxy-status-dot', 'connected', 'Proxy: Connected ✓');
            this.addLog('✅ Proxy server is running on port 8001', 'success');
            return true;
        } catch (error) {
            this.updateStatusDot('proxy-status-dot', 'disconnected', 'Proxy: Not running ✗');
            this.addLog('❌ Proxy server not running on port 8001', 'error');
            this.addLog('💡 Start proxy with: python proxy.py', 'warning');
            return false;
        }
    }

    updateStatusDot(elementId, status, text) {
        const dot = document.getElementById(elementId);
        if (dot) {
            dot.setAttribute('data-status', status);
            dot.parentElement.textContent = text;
            dot.parentElement.insertBefore(dot, dot.parentElement.firstChild);
        }
    }

    addLog(message, type = 'info') {
        const logContent = document.getElementById('log-content');
        if (!logContent) return;

        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logContent.appendChild(entry);
        
        // Auto-scroll to bottom
        logContent.scrollTop = logContent.scrollHeight;
    }

    clearConnectionLog() {
        const logContent = document.getElementById('log-content');
        if (logContent) {
            logContent.innerHTML = '';
        }
    }
}

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', () => {
    console.log('🎨 Starting Simple ASCII Art Generator...');
    new SimpleASCIIArt();
});
